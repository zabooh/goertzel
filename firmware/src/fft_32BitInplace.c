/* fft.c  --  in-place decimation-in-time FFT */

#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include "fft_32BitInplace.h"

#include "definitions.h"    



///* these arrays will be used by the FFT function */
//FFT_complex FFT32BitInplace_Buffer[FFT_LENGTH]; /* complex input data */
//uint32_t FFT32BitInplace_PowerSpectrum[FFT_LENGTH / 2]; /* power spectral density */
//FFT_NU_TYPE FFT32BitInplace_StepResponse[FFT_LENGTH];


static inline FFT_complex FFT_cmplx(FFT_NU_TYPE x, FFT_NU_TYPE y); /* z = cmplx(x,y) = x+jy */
static inline FFT_complex FFT_cadd(FFT_complex a, FFT_complex b); /* complex addition */
static inline FFT_complex FFT_csub(FFT_complex a, FFT_complex b); /* complex subtraction */
static inline FFT_complex FFT_cmul(FFT_complex a, FFT_complex b); /* complex multiplication */
static inline FFT_complex FFT_cmexp(FFT_complex z); /* complex exponential */



#define TEST_FFT



#define TEST_NUM_OF_SAMPLES  FFT_LENGTH

#define SIZE_OF_DATA	TEST_NUM_OF_SAMPLES
#define SIZE_OF_RESULT	(SIZE_OF_DATA>>1)

union FFT_Data {
    FFT_complex complex[SIZE_OF_DATA];
    int32_t result[SIZE_OF_DATA];
};

union FFT_Data fftData;

// Peak of 78 at Index (TEST_NUM_OF_SAMPLES / 8)
// 50kHz Samplerate filled with decayed sine pulse at 12.5kHz
// 1024 values between 0 and 1023 with DC Offset at 506

#define NUM_OF_SAMPLES (1024)

#ifdef TEST_FFT
const uint16_t test_sine_wave[NUM_OF_SAMPLES] = {
    0x1FA, 0x3FF, 0x1FA, 0x000, 0x1FA, 0x3EB, 0x1FA, 0x014,
    0x1FA, 0x3D7, 0x1FA, 0x027, 0x1FA, 0x3C5, 0x1FA, 0x039,
    0x1FA, 0x3B3, 0x1FA, 0x04B, 0x1FA, 0x3A1, 0x1FA, 0x05C,
    0x1FA, 0x391, 0x1FA, 0x06C, 0x1FA, 0x381, 0x1FA, 0x07C,
    0x1FA, 0x372, 0x1FA, 0x08B, 0x1FA, 0x363, 0x1FA, 0x099,
    0x1FA, 0x355, 0x1FA, 0x0A7, 0x1FA, 0x347, 0x1FA, 0x0B4,
    0x1FA, 0x33A, 0x1FA, 0x0C1, 0x1FA, 0x32E, 0x1FA, 0x0CD,
    0x1FA, 0x321, 0x1FA, 0x0D9, 0x1FA, 0x316, 0x1FA, 0x0E4,
    0x1FA, 0x30B, 0x1FA, 0x0EF, 0x1FA, 0x300, 0x1FA, 0x0FA,
    0x1FA, 0x2F6, 0x1FA, 0x104, 0x1FA, 0x2EC, 0x1FA, 0x10E,
    0x1FA, 0x2E3, 0x1FA, 0x117, 0x1FA, 0x2D9, 0x1FA, 0x120,
    0x1FA, 0x2D1, 0x1FA, 0x128, 0x1FA, 0x2C8, 0x1FA, 0x131,
    0x1FA, 0x2C0, 0x1FA, 0x138, 0x1FA, 0x2B8, 0x1FA, 0x140,
    0x1FA, 0x2B1, 0x1FA, 0x147, 0x1FA, 0x2AA, 0x1FA, 0x14E,
    0x1FA, 0x2A3, 0x1FA, 0x155, 0x1FA, 0x29C, 0x1FA, 0x15C,
    0x1FA, 0x296, 0x1FA, 0x162, 0x1FA, 0x290, 0x1FA, 0x168,
    0x1FA, 0x28A, 0x1FA, 0x16E, 0x1FA, 0x284, 0x1FA, 0x173,
    0x1FA, 0x27F, 0x1FA, 0x178, 0x1FA, 0x27A, 0x1FA, 0x17E,
    0x1FA, 0x275, 0x1FA, 0x182, 0x1FA, 0x270, 0x1FA, 0x187,
    0x1FA, 0x26B, 0x1FA, 0x18C, 0x1FA, 0x267, 0x1FA, 0x190,
    0x1FA, 0x263, 0x1FA, 0x194, 0x1FA, 0x25F, 0x1FA, 0x198,
    0x1FA, 0x25B, 0x1FA, 0x19C, 0x1FA, 0x257, 0x1FA, 0x1A0,
    0x1FA, 0x253, 0x1FA, 0x1A3, 0x1FA, 0x250, 0x1FA, 0x1A7,
    0x1FA, 0x24C, 0x1FA, 0x1AA, 0x1FA, 0x249, 0x1FA, 0x1AD,
    0x1FA, 0x246, 0x1FA, 0x1B0, 0x1FA, 0x243, 0x1FA, 0x1B3,
    0x1FA, 0x240, 0x1FA, 0x1B6, 0x1FA, 0x23E, 0x1FA, 0x1B9,
    0x1FA, 0x23B, 0x1FA, 0x1BB, 0x1FA, 0x238, 0x1FA, 0x1BE,
    0x1FA, 0x236, 0x1FA, 0x1C0, 0x1FA, 0x234, 0x1FA, 0x1C2,
    0x1FA, 0x231, 0x1FA, 0x1C4, 0x1FA, 0x22F, 0x1FA, 0x1C7,
    0x1FA, 0x22D, 0x1FA, 0x1C9, 0x1FA, 0x22B, 0x1FA, 0x1CB,
    0x1FA, 0x229, 0x1FA, 0x1CC, 0x1FA, 0x227, 0x1FA, 0x1CE,
    0x1FA, 0x226, 0x1FA, 0x1D0, 0x1FA, 0x224, 0x1FA, 0x1D2,
    0x1FA, 0x222, 0x1FA, 0x1D3, 0x1FA, 0x221, 0x1FA, 0x1D5,
    0x1FA, 0x21F, 0x1FA, 0x1D6, 0x1FA, 0x21E, 0x1FA, 0x1D8,
    0x1FA, 0x21C, 0x1FA, 0x1D9, 0x1FA, 0x21B, 0x1FA, 0x1DA,
    0x1FA, 0x21A, 0x1FA, 0x1DC, 0x1FA, 0x219, 0x1FA, 0x1DD,
    0x1FA, 0x217, 0x1FA, 0x1DE, 0x1FA, 0x216, 0x1FA, 0x1DF,
    0x1FA, 0x215, 0x1FA, 0x1E0, 0x1FA, 0x214, 0x1FA, 0x1E1,
    0x1FA, 0x213, 0x1FA, 0x1E2, 0x1FA, 0x212, 0x1FA, 0x1E3,
    0x1FA, 0x211, 0x1FA, 0x1E4, 0x1FA, 0x210, 0x1FA, 0x1E5,
    0x1FA, 0x20F, 0x1FA, 0x1E6, 0x1FA, 0x20F, 0x1FA, 0x1E7,
    0x1FA, 0x20E, 0x1FA, 0x1E7, 0x1FA, 0x20D, 0x1FA, 0x1E8,
    0x1FA, 0x20C, 0x1FA, 0x1E9, 0x1FA, 0x20C, 0x1FA, 0x1E9,
    0x1FA, 0x20B, 0x1FA, 0x1EA, 0x1FA, 0x20A, 0x1FA, 0x1EB,
    0x1FA, 0x20A, 0x1FA, 0x1EB, 0x1FA, 0x209, 0x1FA, 0x1EC,
    0x1FA, 0x209, 0x1FA, 0x1ED, 0x1FA, 0x208, 0x1FA, 0x1ED,
    0x1FA, 0x207, 0x1FA, 0x1EE, 0x1FA, 0x207, 0x1FA, 0x1EE,
    0x1FA, 0x206, 0x1FA, 0x1EF, 0x1FA, 0x206, 0x1FA, 0x1EF,
    0x1FA, 0x205, 0x1FA, 0x1F0, 0x1FA, 0x205, 0x1FA, 0x1F0,
    0x1FA, 0x205, 0x1FA, 0x1F0, 0x1FA, 0x204, 0x1FA, 0x1F1,
    0x1FA, 0x204, 0x1FA, 0x1F1, 0x1FA, 0x203, 0x1FA, 0x1F1,
    0x1FA, 0x203, 0x1FA, 0x1F2, 0x1FA, 0x203, 0x1FA, 0x1F2,
    0x1FA, 0x202, 0x1FA, 0x1F2, 0x1FA, 0x202, 0x1FA, 0x1F3,
    0x1FA, 0x202, 0x1FA, 0x1F3, 0x1FA, 0x202, 0x1FA, 0x1F3,
    0x1FA, 0x201, 0x1FA, 0x1F4, 0x1FA, 0x201, 0x1FA, 0x1F4,
    0x1FA, 0x201, 0x1FA, 0x1F4, 0x1FA, 0x200, 0x1FA, 0x1F4,
    0x1FA, 0x200, 0x1FA, 0x1F5, 0x1FA, 0x200, 0x1FA, 0x1F5,
    0x1FA, 0x200, 0x1FA, 0x1F5, 0x1FA, 0x200, 0x1FA, 0x1F5,
    0x1FA, 0x1FF, 0x1FA, 0x1F5, 0x1FA, 0x1FF, 0x1FA, 0x1F6,
    0x1FA, 0x1FF, 0x1FA, 0x1F6, 0x1FA, 0x1FF, 0x1FA, 0x1F6,
    0x1FA, 0x1FF, 0x1FA, 0x1F6, 0x1FA, 0x1FE, 0x1FA, 0x1F6,
    0x1FA, 0x1FE, 0x1FA, 0x1F7, 0x1FA, 0x1FE, 0x1FA, 0x1F7,
    0x1FA, 0x1FE, 0x1FA, 0x1F7, 0x1FA, 0x1FE, 0x1FA, 0x1F7,
    0x1FA, 0x1FE, 0x1FA, 0x1F7, 0x1FA, 0x1FE, 0x1FA, 0x1F7,
    0x1FA, 0x1FD, 0x1FA, 0x1F7, 0x1FA, 0x1FD, 0x1FA, 0x1F7,
    0x1FA, 0x1FD, 0x1FA, 0x1F8, 0x1FA, 0x1FD, 0x1FA, 0x1F8,
    0x1FA, 0x1FD, 0x1FA, 0x1F8, 0x1FA, 0x1FD, 0x1FA, 0x1F8,
    0x1FA, 0x1FD, 0x1FA, 0x1F8, 0x1FA, 0x1FD, 0x1FA, 0x1F8,
    0x1FA, 0x1FD, 0x1FA, 0x1F8, 0x1FA, 0x1FD, 0x1FA, 0x1F8,
    0x1FA, 0x1FC, 0x1FA, 0x1F8, 0x1FA, 0x1FC, 0x1FA, 0x1F8,
    0x1FA, 0x1FC, 0x1FA, 0x1F9, 0x1FA, 0x1FC, 0x1FA, 0x1F9,
    0x1FA, 0x1FC, 0x1FA, 0x1F9, 0x1FA, 0x1FC, 0x1FA, 0x1F9,
    0x1FA, 0x1FC, 0x1FA, 0x1F9, 0x1FA, 0x1FC, 0x1FA, 0x1F9,
    0x1FA, 0x1FC, 0x1FA, 0x1F9, 0x1FA, 0x1FC, 0x1FA, 0x1F9,
    0x1FA, 0x1FC, 0x1FA, 0x1F9, 0x1FA, 0x1FC, 0x1FA, 0x1F9,
    0x1FA, 0x1FC, 0x1FA, 0x1F9, 0x1FA, 0x1FC, 0x1FA, 0x1F9,
    0x1FA, 0x1FC, 0x1FA, 0x1F9, 0x1FA, 0x1FC, 0x1FA, 0x1F9,
    0x1FA, 0x1FB, 0x1FA, 0x1F9, 0x1FA, 0x1FB, 0x1FA, 0x1F9,
    0x1FA, 0x1FB, 0x1FA, 0x1F9, 0x1FA, 0x1FB, 0x1FA, 0x1F9,
    0x1FA, 0x1FB, 0x1FA, 0x1F9, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FB, 0x1FA, 0x1FA,
    0x1FA, 0x1FB, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA,
    0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA, 0x1FA
};  

#endif


int32_t * FFT_32BitInplace(uint16_t *Sample, uint32_t n_data) {
    
    for (int ix = 0; ix < n_data; ix++) {
        fftData.complex[ix].x = 0;
        fftData.complex[ix].y = (int32_t)Sample[ix];
    }
    
    FFT_fft(FFT_LENGTH, fftData.complex);
    
#ifdef __USE_FLOAT    
    for (int ix = 0; ix < SIZE_OF_RESULT; ix++) {
        fftData.result[ix] = 20 * log10(sqrt(pow((float) fftData.complex[ix].x, 2) + pow((float) fftData.complex[ix].y, 2)));    
        
    }
#else
    for (int ix = 0; ix < SIZE_OF_RESULT; ix++) {
        FFT_NU_TYPE magnitude = alpha_max_plus_beta_min(fftData.complex[ix].x, fftData.complex[ix].y);

        FFT_NU_TYPE log_approx = 0;
        while (magnitude > 1) {                       
            magnitude >>= 1;
            log_approx += 6; // Approximation von 20*log10(2)
        }

        fftData.result[ix] = log_approx;
    }
      
#endif
    
  
    return &fftData.result[0];
}

uint32_t FFT_32BitInplace_GetLength(void) {
    return FFT_LENGTH;
}

#define EPSILON 1e-6

static inline int is_zero(float value) {
    return fabs(value) < EPSILON;
}

void FFT_fft(int N, FFT_complex *X) {
    FFT_shuffle(N, X);
    FFT_dftmerge(N, X);
}

/* \(N\) must be a power of 2 */
void FFT_shuffle(int N, FFT_complex *X) {
    int n, r, B = 1;

    /* \(B\) = number of bits */
    while ((N >> B) > 0) {
        B++;
    }

    /* \(N = 2\sp{B}\) */
    B--;

    for (n = 0; n < N; n++) {
        /* bit-reversed version of \(n\) */
        r = FFT_bitrev(n, B);
        /* swap only half of the \(n\)s */
        if (r < n) continue;
        /* swap by addresses */
        FFT_swap(X + n, X + r);
    }
}

int cct=0;

void FFT_dftmerge(int n, FFT_complex *XF) {
    double pi = 4. * atan(1.0);
    int k, i, p, q, m;
    FFT_complex A, B, V, W;

    m = 2;
    /* two \((M/2)\)-DFTs into one \(M\)-DFT  */
    while (m <= n) {
        /* order-\(M\) twiddle factor */        
        W = FFT_cmexp(FFT_cmplx(FFT_Q31X32(0.0), FFT_Q31X32(-2.0 * pi) / m));
        /* successive powers of \(W\) */
        V = FFT_cmplx(FFT_Q31X32(1.0), FFT_Q31X32(0.0));
        /* index for an \((M/2)\)-DFT */
        for (k = 0; k < m / 2; k++) {
            /* \(i\)th butterfly; increment by \(M\) */
            for (i = 0; i < n; i += m) {
                /* absolute indices for */
                p = k + i;
                /* \(i\)th butterfly */
                q = p + m / 2;
                A = XF[p];
                /* \(V = W\sp{k}\) */
                B = FFT_cmul(XF[q], V);
                /* butterfly operations */
                XF[p] = FFT_cadd(A, B);
                XF[q] = FFT_csub(A, B);
            }
            /* \(V = VW = W\sp{k+1}\) */
            V = FFT_cmul(V, W);
        }
        /* next stage */
        m = 2 * m;
    }
}

int FFT_bitrev(int n, int B) {
    int m, r;

    for (r = 0, m = B - 1; m >= 0; m--)
        /* if \(2\sp{m}\) term is present, then */
        if ((n >> m) == 1) {
            /* add \(2\sp{B-1-m}\) to \(r\), and */
            r += TWO(B - 1 - m);
            /* subtract \(2\sp{m}\) from \(n\) */
            n -= TWO(m);
        }
    return (r);
}

void FFT_swap(FFT_complex *a, FFT_complex *b) {
    register FFT_complex t;

    t.x = (*a).x;
    t.y = (*a).y;
    (*a).x = (*b).x;
    (*a).y = (*b).y;
    (*b).x = t.x;
    (*b).y = t.y;

}

/* z = cmplx(x,y) = x+jy */
static inline FFT_complex FFT_cmplx(FFT_NU_TYPE x, FFT_NU_TYPE y) {
    FFT_complex z;

    z.x = x;
    z.y = y;

    return z;
}

/* complex addition */
static inline FFT_complex FFT_cadd(FFT_complex a, FFT_complex b) {
    return FFT_cmplx(a.x + b.x, a.y + b.y);
}

/* complex subtraction */
static inline FFT_complex FFT_csub(FFT_complex a, FFT_complex b) {
    return FFT_cmplx(a.x - b.x, a.y - b.y);
}

/* complex multiplication */
static inline FFT_complex FFT_cmul(FFT_complex a, FFT_complex b) {
    return
    FFT_cmplx(
            FFT_MULT(a.x, b.x) - FFT_MULT(a.y, b.y),
            FFT_MULT(a.x, b.y) + FFT_MULT(a.y, b.x)
            );
}

/* complex exponential */
static inline FFT_complex FFT_cmexp(FFT_complex z) {
    float r = exp(FFT_Q31X32_TO_FLOAT(z.x));

    return
    FFT_cmplx(
            FFT_Q31X32(r * cos(FFT_Q31X32_TO_FLOAT(z.y))),
            FFT_Q31X32(r * sin(FFT_Q31X32_TO_FLOAT(z.y)))
            );
}


#define FIXED_POINT_BITS 16
#define FIXED_POINT_SCALE (1 << FIXED_POINT_BITS)

#define M_FACTOR     0.12345
#define M_FACTOR_FX  ((int32_t)(M_FACTOR * FIXED_POINT_SCALE))

static inline int32_t FxMult(int32_t a, int32_t b) {
    b = b * FIXED_POINT_SCALE;
    int64_t temp = ((int64_t) a * b) >> FIXED_POINT_BITS;
    int32_t result = (int32_t) temp;
    return result;
}


#define ALPHA 0.96043387010342
#define BETA 0.39782473475934

FFT_NU_TYPE __attribute__((optimize("-O1"))) alpha_max_plus_beta_min(FFT_NU_TYPE x, FFT_NU_TYPE y) {
    x = abs(x);
    y = abs(y);

    if (x > y) {
        const int32_t ar32 = (int32_t) (ALPHA * FIXED_POINT_SCALE);
        int64_t ar64 = (int64_t) (x) * ar32;
        int32_t rs32 = (int32_t) (ar64 >> FIXED_POINT_BITS);
        return rs32;
        //return (FFT_NU_TYPE) (ALPHA * (float)x + BETA * (float)y);

    } else {
        const int32_t ar32 = (int32_t) (ALPHA * FIXED_POINT_SCALE);
        int64_t ar64 = (int64_t) (y) * ar32;
        int32_t rs32 = (int32_t) (ar64 >> FIXED_POINT_BITS);
        return rs32;

        //return (FFT_NU_TYPE) (ALPHA * (float)y + BETA * (float)x);
    }
}





#ifdef TEST_FFT
void Test_FFT(uint32_t uSampleRate) {
    asm("nop");

    // The whole function takes 15.6 milli seconds for 512 Data on a Cortex-M0 at 48MHz

    for (int ix = 0; ix < SIZE_OF_DATA; ix++) {
        fftData.complex[ix].x = 0;
        fftData.complex[ix].y = test_sine_wave[ix];
    }

    /***************************************************************************
        
        1024   51.6 ms
         512   24.6 ms
         256   12.2 ms
         128    6.2 ms
          64    3.4 ms
          32    2.2 ms
     
        SIZE_OF_RESULT = FFT_SIZE / 2
        Frequency = Result_Index * ( Samplerate / FFT_SIZE )
        Frequency =     16       * (    50e3    /     64   ) = 12.5kHz
        Frequency =    256       * (    50e3    /   1024   ) = 12.5kHz
      
     **************************************************************************/
    
    //GPIO_PB17_Set();
    FFT_fft(FFT_LENGTH, fftData.complex);
    //GPIO_PB17_Clear();

    // calculating the dB values do need 2 milli seconds
    for (int ix = 0; ix < SIZE_OF_RESULT; ix++) {
        FFT_NU_TYPE magnitude = alpha_max_plus_beta_min(fftData.complex[ix].x, fftData.complex[ix].y);

        FFT_NU_TYPE log_approx = 0;
        while (magnitude > 1) {
#ifndef __USE_FLOAT
            magnitude >>= 1;
#else
            magnitude /= 2;
#endif
            log_approx += 6; // Approximation von 20*log10(2)
        }

        fftData.result[ix] = log_approx;
    }

//    for(int ix=0;ix<SIZE_OF_RESULT;ix++){
//         printf("\n\r%04d  %d", (int) ((float)(ix+1) * (float)(uSampleRate / (float)FFT_LENGTH)),  (int)fftData.result[ix]);
//         SYSTICK_DelayUs(1000);
//    }

    asm("nop");

}

#endif
